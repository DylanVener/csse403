CSSE 220 â€” Object-Oriented Software Development

# COURSE ASSESSMENT REPORT

APPROVED:

## INSTRUCTOR

Michael Hewner (3 sections)
Jason Yoder (5 sections)
Matt Boutell (2 sections)
Mark Hays (1 section)

# RECOMMENDATIONS FROM PREVIOUS OFFERING AND CORRESPONDING CHANGES

* Continue to look for ways to make small exercises.  We did a lot of
  this with OO questions.

This year we also: 

* overhauled the Object Oriented design materials (objectives pretty
  much unchanged, by implementation-wise quite different).
* Reduced the amount of material in the final 3rd of the course, to
  give more in class project work time
* Piloted a reduced threads curriculum

# LEARNING OUTCOMES

Students who successfully complete this course should be able to:

1. Develop software that incorporates the following techniques:
   - Inheritance and class hierarchies
   - Interfaces
   - Polymorphism
   - Casting
   - Exceptions
   - Function objects
   - Generics
   - Collections
   - Event-driven graphical user interfaces
   - Exploring and using large-scale API packages (e.g. GUI libraries)
   - Recursion
2. Perform the following steps of the software development cycle effectively:
   - Design expressed as UML class diagrams
   - Documentation before coding
   - Unit and system testing
3. Explain the implementation of linked lists
4. Analyze the asymptotic worst case run time of simple programs.
5. Predict the performance of simple algorithms, including search and
   sort, given their asymptotic worst, best, and average case run
   times.  
6. Select basic data structures (i.e., arrays, linked lists) based on
   asymptotic time complexity of typical operations.
7. Work in a team of 3-4 students on a small-to-medium-size software
   development project including at least three iterative development
   cycles, demonstrating effective:
   - Use of team roles
   - Team decision making
   - Division of labor
   - Conflict resolution

# MAPPING TO DEPARTMENT STUDENT OUTCOMES

Outcome 1 (insofar as it lays the foundation for object-oriented
design and development) contributes to the following outcomes:

* Effectively apply a variety of computing resources, programming
  languages, programming paradigms, operating systems, networks, and
  software development tools (CS, ICS)

* Apply software engineering theory, principles, tools and processes,
  as well as the theory and principles of computer science and
  mathematics, to the full lifecycle of complex, scalable software
  systems (SE)


# DESCRIPTION OF ASSESSMENT TOOLS 

Written exercises and small programs: Short thought problems,
mathematical analyses, or design exercises.  Students are also asked
to implement a few of the designs.  Written evaluations of team
members.

Programming assignments: Several programming assignments of varying
size and length.

Exams: 2 exams during the term, plus the final exam

Project: A small-to-medium-size software development project including
at least three iterative development cycles done by teams of 3 or 4
students

# COURSE ASSESSMENT MATRIX

| Activity                             | O1 | O2 | O3 | O4 | O5 | O6 | O7 |
|--------------------------------------|----|----|----|----|----|----|----|
| Written exercises and small problems |    | x  | x  | x  | x  |    | x  |
| Programming assignments              | x  |    |    |    |    | x  |    |
| Exams                                | x  |    | x  | x  | x  | x  |    |
| Project                              | x  | x  |    |    |    |    |    |
 
# SUCCESS CRITERIA

The course will be considered fully successful if the following
statement holds for every tool-outcome pair selected above:

Among the students who earn proficient grades in the course, the
average grade on the portions of the assessment tools that are
relevant to the learning outcome is in the proficient range.

## Quantitative Evaluation
The success criteria hold for all tool-outcome pairs.

## Summary of Relevant student feedback

Overall student feedback remains very positive.  Reoccuring concerns:

### UML was hard/confusing/not enough time spent on it

So this term we did a major revamp of the object oriented design
curriculum. What the students are referring to is the new design
questions where you have to evaluate a series of UML diagrams to solve
a problem and then produce one of your own. There are a lot of these
in the new curriculum. Prior to this we were teaching OO design in a
bad way the students really learned hardly anything about it and
nobody complained because it was fairly easy. Now I can see we are
teaching and evaluating it much better students are struggling and
seeing they don't understand it so they have some complaints.

### The main project was too compressed/hard

There are frequently a few student concerns with the project,
generally:

* The project is too hard, or there is not enough time given to do it
* Team members are not pulling their weight

We made some revisions this year to actually make things easier with
the final project (more in class work time, a few clarified examples).
A few other ideas have been floated to further reduce annoyance:

* Reducing the scope slightly and dropping group size to pairs
* Getting team assignment and initial design happening before Exam 2
* Further refining the project related classes to give more timely
  help on issues students struggle with
  
We hope to pilot some of these next year and have a more concrete
recommendation for future years

### Threading is hard, presented at the wrong time, not useful

We are changing the threading requirements for the coming year and
piloted in the Spring.

## Recommendations for the Next Offering

* Continue revisions to the OO-curriculum, try to reduce student
  frustration with UML
* Implement the threading piloting officially
* Consider piloting some ideas to make project easier:
  - Reducing the scope slightly and dropping group size to pairs
  - Getting team assignment and initial design happening before Exam 2
  - Further refining the project related classes to give more timely
    help on issues students struggle with
